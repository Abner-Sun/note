纹理在OpenGL手段操纵复杂的连接之间的四个概念：纹理对象，纹理单元，采样对象和着色器脚本中的sampler uniform。

纹理对象包含的纹理图像本身的数据，即，的纹理。纹理可以是不同的类型（1D，2D，等）具有不同的尺寸和基础数据类型可以有多个格式（RGB，RGBA，等）。OpenGL提供了一种方式来指定内存中的源数据与上述属性的出发点和加载数据到GPU。也有多个参数，可以控制如过滤器类型，等在一个非常类似的方式对顶点缓冲区对象的纹理对象与句柄相关联。在创建句柄和加载纹理数据和参数，你可以简单的开关上的纹理，通过结合不同的句柄到OpenGL的状态。你不再需要加载数据。从现在起，这是确保数据加载时间的GPU渲染之前开始的OpenGL驱动工作。
纹理对象不直接绑定到着色器（实际采样发生）。相反，它绑定到一个纹理单元的指标是传递给着色器。所以材质达到纹理对象通过纹理单元。通常有多个纹理单元提供确切的数目取决于您的图形卡的能力。为了绑定一个纹理对象A到一个纹理单元0你首先需要让纹理单元0活动并绑定纹理对象。你现在可以使纹理单元1激活和绑定不同（或相同）的纹理对象了。纹理单元0保持绑定到对象的纹理A。

There is a bit of complexity in the fact that each texture unit actually has a place for several texture objects simultaneously, as long as the textures are of different types. This is called the 'target' of the texture object. When you bind a texture object to a texture unit you specify the target (1D, 2D, etc). So you can have texture object A bound to the 1D target while object B is bound to the 2D target of the same texture unit.

The sampling operation (usually) takes place inside the fragment shader and there is a special function that does it. The sampling function needs to know the texture unit to access because you can sample from multiple texture unit in the fragment shader. There is a group of special uniform variables for that, according to the texture target: 'sampler1D', 'sampler2D', 'sampler3D', 'samplerCube', etc. You can create as many sampler uniform variables as you want and assign the value of a texture unit to each one from the application. Whenever you call a sampling function on a sampler uniform variable the corresponding texture unit (and texture object) will be used.

The final concept is the sampler object. Don't confuse it with the sampler uniform variable! These are seperate entities. The thing is that the texture object contains both the texture data as well as parameters that configure the sampling operation. These parameters are part of the sampling state. However, you can also create a sampler object, configure it with a sampling state and bind it to the texture unit. When you do that the sampler object will override any sampling state defined in the texture object. Don't worry - for now we won't be using sampler objects at all but it is good to know that they exist.
