常量对象与常量成员函数

常量对象与常量成员函数来防止修改对象，实现最低权限原则。
可以用关键字const来指定对象是不可修改的，任何修改该对象的企图，都会导致编译错误。
例如：const Time noon(12,0,0);    声明一个Time 类的常量对象noon，并将它初始化为中午12点。
C++不允许在常量对象上调用成员函数，除非成员函数本身也被声明为常量。甚至对不会修改对象的成员函数，也是如此，此外，编译器不允许声明常量的成员函数修改对象。
对一般情况下，通常修改对象的构造函数和析构函数而言，它们不允许被声明成const。
关于常量对象和常量成员函数的使用方法如下：
（1）非常量对象调用非常量成员函数         （正确）
（2）非常量对象调用常量成员函数           （正确）
（3）常量对象调用常量成员函数             （正确）
（4）常量对象调用非常量成员函数           （错误）
尽管构造函数必须是非常量成员函数，但它仍然可用于初始化常量对象。
常量对象的“常量性”是在构造函数完成了对象的初始化之后生效的，持续到调用了对象的析构函数。
成员函数没有修改对象的事实，并不足以表明它就是常量函数，常量函数必须显式地用const声明。
常量成员函数的初始化必须用初始化列表。
例如：Increment::Increment(int c,int i) : count(c),increment(i);{}
初始化列表出现在构造函数的参数表 和 表示构造函数函数体开始的左大括号之间。成员初始化列表用冒号和参数表隔开。
常量数据成员（常量对象和常量变量）以及被声明为引用的数据成员，都必须用成员初始化列表初始化，在构造函数中对这些类型的数据赋值是不允许的。

常量成员函数  

const 限定类的成员函数： 

class classname { 
　public: 
　　int fun() const; 
　..... 
} 

　　注意：采用此种const 后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const,因为const已经成为类型信息的一部分。 

获得能力：可以操作常量对象。 

失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。 


楼主的这篇文章值得仔细阅读。但是，我觉得上述“const 限定类的成员函数”这一部分写得比较简略，特别是其中“注意”后面的文字，更是使人不知所云，所以想对这一部分做一些补充说明。 

类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。 

在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更加明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。 

除此之外，在类的成员函数后面加 const 还有什么好处呢？楼主告诉我们的：“获得能力：可以操作常量对象”，其实应该是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。 

对于const成员函数，"不能修改类的数据成员，不能在函数中调用其他不是const的函数"，这是由const的属性决定的，楼主说得完全正确。