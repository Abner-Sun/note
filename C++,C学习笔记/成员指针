是C++中用于对类中成员进行操作。
成员指针的定义格式：成员类型 类名::*指针名=&类名::非静态数据成员;
成员函数指针的定义格式: 成员函数返回类型 类名::*指针名 = &类名::成员函数名（参数表）;
例：class A
{
int m;
public:
void func(){};
...
};
定义成员指针： int A::*p = &A::m;
定义成员函数指针： void (A::*f)() = &A::func;


区别
普通指针用确定对象的地址进行初始化，指向一个确定的对象；成员指针用类的成员（注意不是对象的成员，而是类的成员）初始化（也就是只有偏移量的信息，而没有初始地址的信息）。
1）在处理一般指针时，可以隐式的将一个指向子类类型的指针转换成一个基类类型的指针，相反则不行。如：
class BASE{
virtual void func();
};
class DERVIED : public BASE{
void func();
};
BASE *bp = new DERVIED; //OK, convert 'DERVIED*' to 'BASE*'
DERVIED *bp = new BASE; //error, can not convert 'BASE*' to 'DERVIED*'
2）对于成员指针，与一般指针刚好相反，一个指向基类的成员指针可以隐式转换成指向子类相应成员指针，相反则不行。如(同样采用上面的两个类)：
typedef void (BASE::*BMF)();
typedef void (DERVIED::*DMF)();
BMF bmf1 = &BASE::func; //OK
BMF bmf2 = &DERVIED::func; //error, can not convert 'DERVIED::*' to BMF
DMF dmf1 = &BASE::func; //but this is OK
DMF dmf2 = &DERVIED::func; //OK
由于子类具有基类的所有成员，所以一个子类的成员指针可以指向基类的相应成员，相反，子类可能包含了基类中不存在的成员，所以基类的成员指针不能指向子类成员。


指向非静态数据成员的指针在定义时必须和类相关联，在使用时必须和具体的对象关联。

1. <类对象名>.*<指向非静态数据成员的指针> 

指向静态数据成员的指针的定义和使用与普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。

假设已经定义了一个类student，该类有非静态成员math，静态成员chin-ese，代码演示了指向它们的指针定义方式。

1. student s1;  

2. int student::*pm=&student::math；    //指向非静态属性  

3. s1.*pm=100;                         //设置非静态属性  

4. int *pc=&student::chinese;          //指向静态属性  

5. *pc=10;                             //设置静态属性 

分析：该示例定义了指针pc和pm，分别指向类的静态数据成员chinese和非静态数据成员math。访问pm时，必须使用类实例来修饰。而访问pc时，与普通指针没有区别。

2．指向成员函数的指针

定义一个指向非静态成员函数的指针必须在三个方面与其指向的成员函数保持一致：参数列表要相同、返回类型要相同、所属的类型要相同。定义格式如下：

1. <数据类型>(<类名>::*<指针名>)(<参数列表>)[=&<类名>::<非静态成员函数>] 

使用指向非静态成员函数的指针的方法和使用指向非静态数据成员的指针的方法相同，格式如下：

1. (<类对象名>.*<指向非静态成员函数的指针>)(<参数列表>); 

指向静态成员函数的指针和普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。

1. <数据类型>(*<指针名>)(<参数列表>)[=&<类名>::<静态成员函数>] 

假设类student有非静态成员函数f1，非静态成员函数f2，代码演示指向它们的函数指针的定义方式。

1. student s1;  

2. float (student::*pf1)()=&student::f1;       //指向非静态成员函数的指针  

3. (s1.*pf1)();                                //调用指向非静态成员函数的指针  

4. void (*pf2)()=&student::f2;                 //指向静态成员函数的指针  

5. pf2();                                          //调用静态成员函数 

分析：指向非静态成员函数时，必须用类名作限定符，使用时则必须用类的实例作限定符。指向静态成员函数时，则不需要使用类名作限定符。



