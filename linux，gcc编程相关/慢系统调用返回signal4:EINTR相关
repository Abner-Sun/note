 我们用术语慢系统调用（slow system call）描述accept函数，该术语也适用于那些可能永远阻塞的系统调用。永远阻塞的系统调用有可能永远无法返回，多数网络支持函数都属于这一类。举例来说，如果没有客户连接到服务器上，那么服务器的accept调用就没有返回的保证。类似的，如果客户端从未发送过数据，那么read调用将永不返回。其他慢系统调用的例子是对管道和终端设备的读和写。一个值得注意的例外是磁盘IO，它们一般都会返回到调用者（假设没有灾难性的硬件事故）。
    适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应处理函数返回时，该系统调用可能返回一个EINTR错误。所以，我们必须对慢系统调用返回的EINTR有所准备。
    为了处理被中断的accept,可以改成如下形式：
for (;;) 
{
    if((connfd=accept(listenfd,NULL, NULL)) < 0) 
    {
        if (errno == EINTR)
            continue;
        else
            printf("accept error");
    } 
}
    这段代码所做的事情就是自己重启被中断的系统调用。对于accept，以及诸如read、write、select和open之类的函数，这是适合的。不过有一个函数我们不能重启:connect。如果该函数返回EINTR，我们就不能再次调用它，否则将立即返回一个错误。当connect被一个捕获信号中断而且不自动重启时，我们必须调用select来等待连接完成。


《UNIX网络编程第1卷 套接口API》中，看到了这样的一句话，让我理解了为什么会出现这个错误，原文如下：
“适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。有些内核自动重启某些被中断的系统调用。”
在这里，慢系统调用（slow system call）在书中是指类似accept之类的引起阻塞的函数，而上文讨论过的semop函数，我想应该也是这一类的，所以当现现EINTR信号时，该系统调用被中断，并返回错误，错误号为：EINTR，我们就可以从这个错误号来重新启动我们的系统调用。
