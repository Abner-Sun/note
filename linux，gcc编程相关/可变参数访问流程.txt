含有变长参数的函数是怎么实现的呢？变长参数函数的实现其实关键在于怎么使用参数，指定了的参数好说，直接使用指定的参数名称访问，但未指定的参数呢？我们知道函数调用过程中参数传递是通过栈来实现的，一般调用都是从右至左的顺序压参数入栈，因此参数与参数之间是相邻的，知道前一个参数的类型及地址，根据后一个参数的类型就可以获取后一个参数的内容。对于变长参数函数，结合一定的条件，我们可以根据最后一个指定参数获取之后的省略参数内容。如，对于函数func，我们知道了参数b的地址及类型，就可知道第一个可变参数的栈地址(如果有的话)，如果知道第一个可变参数的类型，就可知道第一个可变参数的内容和第二个可变参数的地址(如果有的话)。以此类推，可以实现对可变参数函数的所有参数的访问。

       那么，要怎么指定上诉的“一定的条件”呢？最简单的方法就像printf等函数一样，使用格式化占位符。分析格式化字符串参数，通过事先定义好的格式化占位符可知可变参数的类型及个数，从而获取各个参数内容。一般对于可变参数类型相同的函数也可直接在强制参数中指定可变参数的个数和类型，这样也能获取各个参数的内容。

       无论哪种，都涉及对栈地址偏移的操作。结合栈存储模式和系统数据类型的字长，我们可根据可变参数的类型很容易得到栈地址的偏移量。这里简单介绍使用va_start、va_arg、va_end三个标准宏来实现栈地址的偏移及获取可变参数内容。这三个宏定义在stdarg.h头文件中，他们可根据预先定义的系统平台自动获取相应平台上各个数据类型的偏移量。

//访问可变参数流程   
  
va_list args; //定义一个可变参数列表   
  
va_start(args,arg);//初始化args指向强制参数arg的下一个参数;   
  
va_arg(args,type);//获取当前参数内容并将args指向下一个参数   
  
...//循环获取所有可变参数内容   
  
va_end(args);//释放args  



eg:
//sum为求和函数，其参数类型都为int,但参数个数不定  
//第一个参数（强制参数）n指定后面有多少可变参数  
int sum(unsigned int n,...)  
{  
   int sum=0;  
   va_list args;  
   va_start(args,n);  
   while(n>0)  
   {  
    //通过va_arg(args,int)依次获取参数的值  
     sum+=va_arg(args,int);  
     n--;  
   }  
   va_end(args);  
   return sum;  
}  

